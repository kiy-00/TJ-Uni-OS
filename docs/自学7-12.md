## 自学 7-12



### 学习目标

* 理解操作系统的设计和实现
* XV6操作系统



### 课程结构



### 操作系统的Perposes

* Abstract H/W	对硬件进行抽象

* Multiplex    在许多应用程序中实现硬件复用（多路复用）
* Isolation    隔离性
* Sharing    用户之间的分享（想想windows）
* Security   安全系统/权限系统/访问控制系统
* Performance    良好的性能
* Range of OSES    同一个操作系统应该能支持许多不同的功能，基于它较大的开发成本



### 操作系统的组织结构



#### O/S ORG



| 文本编译器                                     | C compiler （CC） | shell 命令行界面（CLI）                 | 运行应用程序的地方==（userspace）==                          | ==**用户程序和内核之间存在接口**== |      |
| ---------------------------------------------- | ----------------- | --------------------------------------- | ------------------------------------------------------------ | ---------------------------------- | ---- |
| 文件管理系统（FS）实现了文件名、文件内容和目录 | 管理进程          |                                         | 有一个特殊的程序它一直在运行，就是所谓的内核==**（kernel：计算机资源的守护者）**== |                                    |      |
| CPU                                            | ram(内存/RAM)     | disk for storage（用来储存的磁盘/DISK） | network interface (网络接口/NET)                             |                                    |      |



#### 本节课的目的

* 理解在kernel中发生了什么
* 了解存在于用户程序和内核之间的接口
* 了解内核内部的软件结构



### API-kernel（看起来是程序使用的函数调用，但实际上跳转到内核，并执行内核中实现的函数调用）

* fd=open("out",1)
  * 打开了系统调用，实际上是跳转到内核的指定代码
* write(fd,"hello\n",6)
* fork是一个系统调用，它能创建新的进程
  * pid=fork()
  * fork返回标识符，即新进程的进程标识符号pid



### 课程学习难点

* 当我们构建操作系统时，操作系统下直接是硬件
  * 本课程中，我们将使用一个称为QEMU的硬件模拟器，它模拟了CPU和计算机
  * 是一种困难的环境编程
* 必须解决一系列矛盾，需要真正的设计思维
  * 强大的操作系统服务--同时--简单的接口
  * 高效--抽象
  * 灵活性--安全性（在一定程度上约束程序）



### 进一步理解内核

* 一段不会变更的代码
* 有特殊权限
* 在机器启动时加载
* 具有特权
* 很多高级语言在某种程度上是从系统调用中转移出来的
  * 许多语言想要提供可移植的环境
    * python多少与系统调用接口有些隔离



### 系统调用和应用程序的相似之处



### 一些简单的例子（在虚拟机上跟随实验）

