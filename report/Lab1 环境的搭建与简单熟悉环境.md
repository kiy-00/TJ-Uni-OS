## Lab1: 环境的搭建与简单熟悉环境



链接：



### 在VMware上创建一个Ubuntu虚拟机

<img src="C:\Users\yi'k\AppData\Roaming\Typora\typora-user-images\image-20230714101122023.png" alt="image-20230714101122023" style="zoom:50%;" />



### 配置环境

* 参考博客：https://zhuanlan.zhihu.com/p/624091268
* 遇到的问题：各种包没有安装，报了许多error，逐个安装即可

* 简述步骤

  * 安装需要的工具： QEMU 5.1+, GDB 8.3+, GCC, and Binutils.
  * 克隆仓库
    * <img src="C:\Users\yi'k\AppData\Roaming\Typora\typora-user-images\image-20230714101911317.png" alt="image-20230714101911317" style="zoom: 50%;" />

  * 编译成功并进入xv6操作系统的shell，使用chatgpt解决问题
    * <img src="C:\Users\yi'k\AppData\Roaming\Typora\typora-user-images\image-20230714102751646.png" alt="image-20230714102751646" style="zoom:150%;" />



### 关于xv6

* 是一个简化的类似Unix的操作系统
  * Unix是许多现代操作系统（如Linux和OS X）的基础
  * 麻雀虽小五脏俱全

* 运行在RISC-V微处理器上
* QEMU是一个模拟器，用C语言编写。xv6运行在这个模拟器之上
* 带有少量实用程序
  * ==**ls程序，启动后它会给出一个所有文件的列表**==
  
    * ![image-20230714104019089](C:\Users\yi'k\AppData\Roaming\Typora\typora-user-images\image-20230714104019089.png)
  
    * `README`: 这是一个文件，通常包含有关目录或项目的基本信息，如使用方法，依赖项，联系信息等。
    * `xargstest.sh`: 这看起来像是一个 ==**shell 脚本文件**==，可能用于测试或者示例。==**"xargs" 是一个 Unix 命令行工具，用于从标准输入读取参数并构建并执行命令。**==
    * `cat`: 这是一个标准 Unix 工具，==**用于串联和打印文件的内容。**==
    * `echo`: 这个命令==**用于在命令行中输出文本或变量。**==
    * `forktest`: 这可能是一个==**特定的测试程序，用于测试操作系统的 fork 系统调用或进程创建。**==
    * `grep`: 这是一个==**强大的文本搜索工具，可以使用正则表达式来查找文件或命令输出中的文本。**==
    * `init`: 这==**是 Unix 和 Unix-like 系统的初始进程。它是所有其他进程的父进程，并负责在系统启动时启动其他进程。**==
    * `kill`: 这个命令==**用于发送信号给其他进程。最常见的用途是停止（“kill”）进程。**==
    * `ln`: 这个命令==**用于创建链接。可以创建硬链接或符号链接。**==
    * `ls`: 这个命令==**用于列出目录中的文件和子目录。**==
    * `mkdir`: 这个命令==**用于创建新的目录。**==
    * `rm`: 这个命令==**用于删除文件或目录。**==
    * `sh`: ==**这是一个 shell，或者命令行解释器。用户可以在其中输入命令。**==
    * `stressfs`: 这可能是一个==**用于给文件系统添加压力或进行压力测试的程序。**==
    * `usertests`: 这可能是==**一组用于测试用户空间功能或应用程序的测试。**==
    * `grind`: 这可能是一个特定的工具或程序。
    * `wc`: 这是一个==**计数工具，用于计算给定输入中的字节数，字数，和行数。**==
    * `zombie`: 这可能是一个==**用于生成或处理僵尸进程的工具或测试。**==
    * `console`: 这可能是一个==**特殊的设备文件，代表物理或虚拟控制台。**==
  
    以上这些都是在 Unix 或类 Unix 系统中常见的工具或应用程序，一般都在 `/bin` 或 `/usr/bin` 目录下。



### 热身实验

* 演示系统调用的copy（可能是安装的xv6版本不同或者输入的命令不对，我并没有找到copy.c这个文件）

  * ```c++
    int main()
    {
        char buf[64];
        
        while(1){
            int n=read(0, buf, sizeof(buf));
            if(n<=0)
                break;
            write(1,buf,n);
        }
        
        exit(0);
    }
    ```

  * read调用

    * 三个参数
    * 第一个参数：文件描述符，实际上是对以前打开的文件的引用。shell确保程序启动时，默认情况下它的==**文件描述符0连接到console输入，文件描述符1连接到console输出。**==（由此能对copy进行输入并等待它的输出）==**01文件描述符是unix的惯例。**==
    * 第二个参数：是指向某一段内存的指针，程序可以通过指针对应的地址读取内存中的数据，上面代码的第三行在栈里申请了64字节内存，以便read将数据保存。
    * 第三个参数：代码想读取的最大长度
    * 返回值：可能是读取到的字节数，当返回-1时说明出错了

* ![image-20230714112750392](C:\Users\yi'k\AppData\Roaming\Typora\typora-user-images\image-20230714112750392.png)

重装为2021版本的，看起来与2020没什么区别

* open.c

  * ```c++
    int main()
    {
        int fd = open("output.txt", O_WRONLY | O_CREATE);
        write(fd, "ooo\n", 4);
        
        exit(0);
    }
    ```

  * open返回一个新分配的文件描述符，文件描述符只是一个小数字，可能是2，3或4等。

  * 对于文件描述符索引用的文件，有多种方式写入数据，==**文件描述符实际做的是索引到内核内的一个小表，这个表维护每个进程的状态，运行我们运行的每个程序。内核根据文件描述符记住每个运行进程的索引表，这个表告诉内核每个文件描述符指的是什么。**==*关键：每个进程都有自己的文件描述符空间，当两个不同进程的程序都打开了同一个文件，它们可能会得到相同的文件描述符编号，但是因为内核为每个进程维护单独的文件描述符，相同的文件描述符号，在不同的进程中可能对应不同的文件。*

* shell功能的演示：

  * 输入ls时，意味着要求shell运行名为ls的程序
  * 自己尝试

* ==**解决问题：输入cat看不到源码，原因如下，切换到主机系统模式并在正确的文件目录下打开终端，再次输入cat命令即可看到源码**==

  * 在 Unix-like 的系统中，`cat` 命令通常用来查看文本文件的内容。==**当你试图使用 `cat` 来查看一个二进制文件（比如一个执行文件或者对象文件）时，你通常会看到一些看起来像乱码的字符。这是因为二进制文件包含了一些不是打印字符的字节，这些字节在终端上显示出来时，看起来就像是乱码。**==

    `ls` 是一个可执行文件，因此它是一个二进制文件。当你运行 `cat ls` 时，你在试图查看这个二进制文件的内容，因此你看到的是乱码。

    ==**如果你想查看 `ls` 程序的源代码，你需要找到它的源代码文件。**==在 xv6 中，`ls` 程序的源代码位于 `ls.c` 文件中。然而，这个文件可能并没有包含在你的 xv6 文件系统镜像中。你可能需要在你的主机系统（也就是你编译和运行 xv6 的系统）上查看这个文件，或者将这个文件添加到你的 xv6 文件系统镜像中。